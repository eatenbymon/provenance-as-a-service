AI（LLM）を主体にしたコーディング・エージェントへ渡すための「一貫した実装・設計ルール」と「プロンプト／受け入れ基準」。
目標：読みやすく保守しやすいクラス設計、十分にコメントされたコード、検証可能なテスト、再現可能なCIパイプライン。

# 高レベル原則

1. **AIファースト**：設計→実装→テスト→ドキュメントの順で、LLMに設計意図を与え逐次生成・検証する。
2. **SOLID 忠実**：単一責任、拡張に開かれ変更に閉じる、依存性逆転などを基準。
3. **説明可能性**：なぜその実装かをコード内コメントと設計ドキュメントで必ず説明する。
4. **テスト駆動の確認**：自動生成されたテストを必ず実行し、定義された基準を満たすこと。
5. **最小特権・安全設計**：外部依存と秘密情報の扱いは厳格に。
6. **再現性**：ビルド・テスト・デプロイが再現できること（ロックファイル、コンテナ等）。

# ファイル・フォルダ構成（推奨）

```
/project-root
  /src
    /package_or_module
      __init__.py
      core.py
      services/
      models/
      adapters/
  /tests
    test_*.py
  /docs
    api.md
    design.md
  Dockerfile
  pyproject.toml or package.json
  requirements.txt or package-lock.json
  CI.yml
  README.md
  LICENSE
```

短くても構造を守る。責務ごとに `services`, `models`, `adapters` を分離。

# クラス設計ガイドライン

* **単一責任**：1クラス = 1責務。複数の振る舞いが見えたら分割する。
* **明示的な境界**：外部（DB, API）アクセスは `Adapter` / `Repository` パターンに集約。副作用を外に出す。
* **不変性を優先**：可能な限りイミュータブル（`frozen dataclass` / `readonly`）を使う。
* **コンストラクタは軽く**：重い処理はコンストラクタで行わない。`initialize()` やファクトリを使う。
* **インターフェース仕様**：public メソッドには契約（引数、返値、例外）を明記する。
* **依存注入**：外部依存は注入してテスト容易性を保つ。
* **エラーハンドリング**：発生可能な例外と回復手段をドキュメント化する。例外は意味のある型で投げる。
* **命名**：`名詞`は型/クラス、`動詞`は関数/メソッド。長すぎず、曖昧さ無く。

# コメント／ドキュメント方針

* **必須：モジュールヘッダ**（このモジュールの目的、主要なクラスと高レベル挙動）。
* **必須：クラス docstring**（責務、主要属性、例外、使用例）。
* **必須：公開メソッド docstring**（引数の型と意味、戻り値、例外、副作用、コスト（時間・IO））。
* **注釈的インラインコメント**：複雑なロジックやトリッキーな決定には数行で理由を記述。
* **TODO/TFIXME**：必ず `TODO(<理由>): <期限 or issue-id>` 形式で残す。期限無ければ issue-id を付ける。
* **コメントは設計意図を含める**：実装理由やトレードオフを短く残す（なぜこのアルゴリズムを選んだか等）。
* **例**（Python docstring スタイル）:

```python
class PaymentProcessor:
    """
    PaymentProcessor は決済処理をラップするクラス。

    責務:
      - 外部決済APIの呼び出しを抽象化する
      - リトライとフォールバック戦略を実装する

    Attributes:
      adapter: PaymentAdapter - 実際の通信を行うアダプタ
    """
```

# コードスタイル（言語共通）

* **型注釈必須**（可能な限り全 public API に型）。
* **リント規則**：言語別の標準（Python: black + isort + flake/ruff、TS: prettier + eslint）を使用。
* **コミット粒度**：1コミット = 1論理変更。コミットメッセージは `type(scope): short-desc`（例：`fix(payment): handle 402 errors`）。
* **ドキュメント自動生成**：公開APIはドキュメントジェネレータで出力できるようコメントを整える。

# テスト方針

* **必須**：ユニットテスト、統合テスト。
* **テスト命名**：`test_<unit>__<condition>__<expected>`（読みやすさ優先）。
* **カバレッジ目標**：主要ロジックで 80% 以上（安全クリティカルなら 90%）。ただしカバレッジは品質の指標であって目的ではない。
* **テストデータ**：固定ランダムシードを使い再現性を担保。外部APIはモック/スタブ。
* \*\* property-based testing の活用\*\*：入力の境界・ランダム化テストでロバスト性チェック。
* **CIでの自動実行**：すべての PR に対してユニット・統合テストを実行。テスト失敗でマージ不可。

# セキュリティと秘密情報

* **環境変数**：秘密は環境変数またはシークレットマネージャに格納。コード内ハードコード禁止。
* **依存関係スキャン**：Snyk, Dependabot、OSSライセンス確認。
* **入力検証**：外部入力は最初に検証・正規化。SQL/コマンド注入に注意。
* **ログ**：PⅡ（個人情報）はログに出さない。出す場合はマスキングを必須に。
* **権限**：最低限の権限で動作すること（DB/外部APIキーなど）。

# CI / CD（推奨ワークフロー）

1. PR 作成 → CI トリガー。
2. ステップ：lint → typecheck → unit tests → integration tests → static analysis（セキュリティ）→ build。
3. 成功時に自動デプロイ（ステージング）。手動承認で本番へ。
4. アーティファクト（Docker イメージやパッケージ）はタグ付けし、リリースノートを自動生成。


* **設計フェーズ**：

  * プロンプトで「要件」「非機能要件」「API契約」「制約」を渡し、クラス図・シーケンス図（テキスト）・エンドポイント一覧を生成させる。
  * 出力は必ず「要約（50字）」「設計（詳細）」「リスク/留意点」「推奨テストケース」を返させる。
* **実装フェーズ**：

  * LLM に対して「ファイル単位」で作成を指示する。各ファイル生成後、自動で unit test を生成させる。
  * 実装は「言語」「フレームワーク」「リンター」ルールを含むテンプレートで行う。
* **レビュー・改善**：

  * LLM に対し `explainability` タスクを与え、各関数の時間/空間計算量、依存関係、代替案を列挙させる。
  * 既存コードを与え「リファクタ提案」「潜在バグ検出」「性能ボトルネック」を返すプロンプトを必須にする。
* **テスト自動化**：

  * LLM にテストケース設計（境界条件、異常系、競合/並行性）を生成させて、モックも生成する。
* **プロンプトの一貫性**：テンプレートを必ず使う（後述）。
```

# コードレビュー基準

* 可読性：20点（命名、構造、コメント）
* テスト：20点（網羅性、正常系・異常系）
* 設計：20点（SRP、DI、境界）
* セキュリティ：15点（秘密管理、入力検証）
* パフォーマンスとスケーラビリティ：15点
* ドキュメント：10点（モジュール/クラス/メソッド docstrings）
  合格ライン：70点以上。レビューは差分に対して具体的な修正案を提示すること。

# 受け入れテスト（PRマージ基準）

* 全CIチェック合格（lint, typecheck, tests, security scan）。
* 主要ロジックのユニットテストが存在し、CI上で合格。
* 変更点の設計理由が `design.md` に記載され、レビュー応答が完了している。
* 互換性：破壊的変更は明示し、移行手順を添付。
* ドキュメント：`README.md` と API ドキュメントが更新されている。

# 出力形式ルール（LLMに渡す）

* 生成物は必ず `files` オブジェクト（`path` と `content`）で返す。
* テストは独立して実行可能で、サンプル入力と期待値を含める。
* 変更ログは `changelog.md` 形式で短く。
* 依存関係に変更がある場合、`lockfile` の差分を示す。









---

